package org.rcsb.cif.model.diffrnsource;

import org.rcsb.cif.model.BaseCategory;
import org.rcsb.cif.model.Column;

import javax.annotation.Generated;
import java.util.Map;

@Generated("org.rcsb.cif.internal.generator.SchemaGenerator")
public class DiffrnSource extends BaseCategory {
    public DiffrnSource(String name, Map<String, Column> columns) {
        super(name, columns);
    }

    public DiffrnSource(String name, int rowCount, Object[] encodedColumns) {
        super(name, rowCount, encodedColumns);
    }

    public DiffrnSource(String name) {
        super(name);
    }

    /**
     * The current in milliamperes at which the radiation source
     * was operated.
     * @return Current
     */
    public Current getCurrent() {
        return (Current) (isText ? textFields.computeIfAbsent("current",
                Current::new) : getBinaryColumn("current"));
    }

    /**
     * A description of special aspects of the radiation source used.
     * @return Details
     */
    public Details getDetails() {
        return (Details) (isText ? textFields.computeIfAbsent("details",
                Details::new) : getBinaryColumn("details"));
    }

    /**
     * This data item is a pointer to _diffrn.id in the DIFFRN
     * category.
     * @return DiffrnId
     */
    public DiffrnId getDiffrnId() {
        return (DiffrnId) (isText ? textFields.computeIfAbsent("diffrn_id",
                DiffrnId::new) : getBinaryColumn("diffrn_id"));
    }

    /**
     * The power in kilowatts at which the radiation source
     * was operated.
     * @return Power
     */
    public Power getPower() {
        return (Power) (isText ? textFields.computeIfAbsent("power",
                Power::new) : getBinaryColumn("power"));
    }

    /**
     * The dimensions of the source as viewed from the sample.
     * @return Size
     */
    public Size getSize() {
        return (Size) (isText ? textFields.computeIfAbsent("size",
                Size::new) : getBinaryColumn("size"));
    }

    /**
     * The general class of the radiation source.
     * @return Source
     */
    public Source getSource() {
        return (Source) (isText ? textFields.computeIfAbsent("source",
                Source::new) : getBinaryColumn("source"));
    }

    /**
     * The chemical element symbol for the X-ray target
     * (usually the anode) used to generate X-rays.
     * This can also be used for spallation sources.
     * @return Target
     */
    public Target getTarget() {
        return (Target) (isText ? textFields.computeIfAbsent("target",
                Target::new) : getBinaryColumn("target"));
    }

    /**
     * The make, model or name of the source of radiation.
     * @return Type
     */
    public Type getType() {
        return (Type) (isText ? textFields.computeIfAbsent("type",
                Type::new) : getBinaryColumn("type"));
    }

    /**
     * The voltage in kilovolts at which the radiation source was
     * operated.
     * @return Voltage
     */
    public Voltage getVoltage() {
        return (Voltage) (isText ? textFields.computeIfAbsent("voltage",
                Voltage::new) : getBinaryColumn("voltage"));
    }

    /**
     * The complement of the angle in degrees between the normal
     * to the surface of the X-ray tube target and the primary
     * X-ray beam for beams generated by traditional X-ray tubes.
     * @return Take_offAngle
     */
    public Take_offAngle getTake_offAngle() {
        return (Take_offAngle) (isText ? textFields.computeIfAbsent("take-off_angle",
                Take_offAngle::new) : getBinaryColumn("take-off_angle"));
    }

    /**
     * Comma separated list of wavelengths or wavelength range.
     * @return PdbxWavelengthList
     */
    public PdbxWavelengthList getPdbxWavelengthList() {
        return (PdbxWavelengthList) (isText ? textFields.computeIfAbsent("pdbx_wavelength_list",
                PdbxWavelengthList::new) : getBinaryColumn("pdbx_wavelength_list"));
    }

    /**
     * Wavelength of radiation.
     * @return PdbxWavelength
     */
    public PdbxWavelength getPdbxWavelength() {
        return (PdbxWavelength) (isText ? textFields.computeIfAbsent("pdbx_wavelength",
                PdbxWavelength::new) : getBinaryColumn("pdbx_wavelength"));
    }

    /**
     * Synchrotron beamline.
     * @return PdbxSynchrotronBeamline
     */
    public PdbxSynchrotronBeamline getPdbxSynchrotronBeamline() {
        return (PdbxSynchrotronBeamline) (isText ? textFields.computeIfAbsent("pdbx_synchrotron_beamline",
                PdbxSynchrotronBeamline::new) : getBinaryColumn("pdbx_synchrotron_beamline"));
    }

    /**
     * Synchrotron site.
     * @return PdbxSynchrotronSite
     */
    public PdbxSynchrotronSite getPdbxSynchrotronSite() {
        return (PdbxSynchrotronSite) (isText ? textFields.computeIfAbsent("pdbx_synchrotron_site",
                PdbxSynchrotronSite::new) : getBinaryColumn("pdbx_synchrotron_site"));
    }

    /**
     * Yes/No if synchrotron source was used or not.
     * @return PdbxSynchrotronYN
     */
    public PdbxSynchrotronYN getPdbxSynchrotronYN() {
        return (PdbxSynchrotronYN) (isText ? textFields.computeIfAbsent("pdbx_synchrotron_y_n",
                PdbxSynchrotronYN::new) : getBinaryColumn("pdbx_synchrotron_y_n"));
    }

    /**
     * Beamline for synchrotron source.
     * @return PdbxSourceSpecificBeamline
     */
    public PdbxSourceSpecificBeamline getPdbxSourceSpecificBeamline() {
        return (PdbxSourceSpecificBeamline) (isText ? textFields.computeIfAbsent("pdbx_source_specific_beamline",
                PdbxSourceSpecificBeamline::new) : getBinaryColumn("pdbx_source_specific_beamline"));
    }
}
